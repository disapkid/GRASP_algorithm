#pragma once
#include <parser.hpp>
#include <numeric>
#include <algorithm>
#include <random>

struct Candidate {
    int index;
    int value;
    int delta;
};

class GRASP final {
public:
    /**
     * @brief Подсчёт числа истинных клауз при полном или частичном присваивании
     *
     * Клауза считается истинной, если хотя бы один её литерал истинный.
     * 
     * Истинность литерала определяется так:
     *    - литерал v  (положительный) истинный, если x[v] == 1
     *    - литерал -v (отрицательный) истинный, если x[v] == 0
     *
     * Если значение переменной x[v] == -1 (неопределено),
     * литерал считается "неопределённым" и не может сделать клаузу истинной.
     *
     * Функция проходит по всем клаузам формулы и считает,
     * сколько из них истинны хотя бы по одному литералу.
     *
     * @returns Количество истинных клауз.
     */
    static int evaluate(const Formula& formula, const std::vector<int>& x);


    /**
    * @brief Построение начального приближения (construction phase) для GRASP
    *
    * Алгоритм выполняется итеративно, пока не будут назначены все переменные.
    *
    * 1) Создаётся частичное решение: x[v] = -1 означает "значение переменной не назначено".
    *
    * 2) Формируется список неназначенных переменных.
    *
    * 3) Вычисляется текущее количество истинных клауз для частичного решения.
    *
    * 4) Для каждой неназначенной переменной v рассматриваются два кандидата:
    *      - присвоить x[v] = 0
    *      - присвоить x[v] = 1
    *    Для каждого варианта вычисляется число истинных клауз и дельта относительно текущего состояния.
    *
    * 5) Все кандидаты сортируются по убыванию дельты (жадная стратегия).
    *
    * 6) Строится ограниченный список кандидатов (RCL) из первых rcl_size лучших вариантов.
    *
    * 7) Один кандидат случайно выбирается из RCL. Его присвоение фиксируется.
    *
    * 8) Переменная удаляется из списка неназначенных, текущее число истинных клауз обновляется.
    *
    * 9) Процесс повторяется, пока все переменные не будут назначены.
    */
    static void grasp_construct(const Formula& formula, std::vector<int>& x, int rcl_size, std::mt19937& mt);

    static void local_search(const Formula& formula, std::vector<int>& x);

    static int iteration(const Formula& formula, int rcl_size, std::mt19937& mt);
};
